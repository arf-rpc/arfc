package golang

import (
	"fmt"
	"github.com/arf-rpc/arfc/arf/common"
	"github.com/arf-rpc/arfc/arf/strcase"
	"github.com/arf-rpc/arfc/output"
	"github.com/arf-rpc/idl/ast"
	"github.com/urfave/cli/v2"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func NewGenerator(tree *ast.PackageTree) common.Generator {
	return &Generator{
		t: tree,
		w: &common.Writer{},
	}
}

type Generator struct {
	t *ast.PackageTree
	w *common.Writer

	requiredPackages     []string
	structuresToRegister []string
	mod                  string
	packageMapping       map[string]string
	ctx                  *cli.Context
}

var goModRegexp = regexp.MustCompile("^module (.*)$")

func (g *Generator) findGoMod() {
	if mod := g.ctx.String("golang-module"); mod != "" {
		g.mod = mod
		return
	}
	outputPath := g.ctx.String("output")
	abs, err := filepath.Abs(outputPath)
	if err != nil {
		output.Errorf("Cannot determine absolute path to %s: %s", outputPath, err.Error())
		os.Exit(1)
		return
	}
	components := strings.Split(abs, "/")
	for len(components) > 1 {
		modPath := "/" + filepath.Join(append(components, "go.mod")...)
		data, err := os.ReadFile(modPath)
		if err != nil {
			components = components[:len(components)-1]
			continue
		}
		for _, line := range strings.Split(string(data), "\n") {
			mod := goModRegexp.FindSubmatch([]byte(line))
			if mod == nil {
				continue
			}
			g.mod = string(mod[1])
			return
		}
		output.Warnf("Invalid go.mod at %s: No module line found.", modPath)
		components = components[:len(components)-1]
	}

	output.Errorf("Could not find a go.mod in the current tree, nor one was provided through the --go-module flag. Aborting...")
	os.Exit(1)
	return
}

func (g *Generator) resolvePackage(name string, packageName string) string {
	// Ok, just need to figure out where packageName will be created based on
	// modPath, and add it to the import list.
	pathForPackage, ok := g.pathForPackage(packageName)
	list := strings.Split(pathForPackage, "/")
	if !ok {
		list = strings.Split(packageName, ".")
		g.requirePackage(g.mod + "/" + strings.Join(list, "/"))
	} else {
		g.requirePackage(g.mod + "/" + pathForPackage)
	}

	return list[len(list)-1]
}

func (g *Generator) pathForPackage(pkg string) (string, bool) {
	if g.packageMapping == nil {
		g.packageMapping = map[string]string{}
		for _, m := range g.ctx.StringSlice("golang-package") {
			comps := strings.SplitN(m, "=", 2)
			g.packageMapping[strings.TrimSpace(comps[0])] = strings.TrimSpace(comps[1])
		}
	}
	pkg, ok := g.packageMapping[pkg]
	return pkg, ok
}

func (g *Generator) GenFile(ctx *cli.Context) (data []byte, targetDir string, targetFile string) {
	g.ctx = ctx
	g.findGoMod()
	pkgComps := strings.Split(g.t.Package, ".")
	pkg := pkgComps[len(pkgComps)-1]
	if p, ok := g.pathForPackage(g.t.Package); ok {
		pkg = p
	}

	targetDir = filepath.Join(ctx.String("output"), pkg)
	targetFile = pkg + ".arf.go"

	g.requirePackage(
		"github.com/arf-rpc/arf-go/proto",
		"sync",
	)

	for _, e := range g.t.Enums {
		g.makeEnum(&e)
	}

	for _, s := range g.t.Structures {
		g.makeStruct(&s)
	}

	for _, s := range g.t.Services {
		g.makeService(&s)
	}

	for _, s := range g.t.Services {
		g.makeClient(&s)
	}

	g.w.Merge(g.makeRegister())

	g.w.Merge(g.makeHeader(pkg))

	formatted, err := format.Source([]byte(g.w.String()))
	if err != nil {
		tmpfile, tmpErr := os.CreateTemp("", "*.go")
		if tmpErr != nil {
			output.Errorf("Failed to format generated file: %s. Failed to obtain temporary file to store source for inspection: %s", err, tmpErr)
		}

		_, tmpErr = tmpfile.Write([]byte(g.w.String()))
		if tmpErr != nil {
			_ = tmpfile.Close()
			output.Errorf("Failed to format generated file: %s. Failed to write temporary file to store source for inspection: %s", err, tmpErr)
		}
		_ = tmpfile.Close()
		output.Errorf("Failed to format generated file: %s. Generated source has been kept for inspection: %s", err, tmpfile.Name())
	}

	data = formatted
	return
}

func (g *Generator) requirePackage(name ...string) {
	g.requiredPackages = append(g.requiredPackages, name...)
}

func (g *Generator) makeHeader(pkg string) *common.Writer {
	w := &common.Writer{}

	w.Writelnf("// Code generated by arfc. DO NOT EDIT.")
	w.Writelnf("")
	w.Writelnf("package %s", pkg)
	w.Writelnf("")
	w.Writelnf("import (")

	imported := map[string]struct{}{}

	for _, v := range g.requiredPackages {
		if _, ok := imported[v]; ok {
			continue
		}
		imported[v] = struct{}{}
		w.Writelnf("%q", v)
	}

	w.Writelnf(")")
	return w
}

func (g *Generator) writeComments(c []string) {
	for _, c := range c {
		g.w.Writelnf("// %s", c)
	}
}

func composedPackage(pkg string) string {
	comps := strings.Split(pkg, ".")
	return strcase.ToLowerCamel(strings.Join(comps, "_"))
}

func (g *Generator) makeRegister() *common.Writer {
	w := &common.Writer{}
	pkgName := composedPackage(g.t.Package)
	w.Writelnf("var __arfStructRegisterer%s sync.Once", pkgName)
	w.Writelnf("func __arfRegister%sStructures() {", pkgName)
	w.Writelnf("__arfStructRegisterer%s.Do(func() {", pkgName)
	for _, v := range g.structuresToRegister {
		w.Writelnf("proto.RegisterMessage(%s{})", v)
	}
	w.Writelnf("})")
	w.Writelnf("}")
	w.Writelnf("")
	return w
}

func (g *Generator) makeEnum(e *ast.Enum) {
	g.writeComments(e.Comment)
	if ann := e.Annotations.ByName("deprecated"); ann != nil {
		g.w.Writelnf("// Deprecated: %s", ann.Arguments[0])
	}
	eName := common.EnumName(e)
	g.w.Writelnf("type %s int", eName)
	g.w.Break()

	g.w.Writelnf("const (")
	for _, v := range e.Members {
		g.writeComments(v.Comment)
		if ann := v.Annotations.ByName("deprecated"); ann != nil {
			g.w.Writelnf("// Deprecated: %s", ann.Arguments[0])
		}
		g.w.Writelnf("%s %s = %d", v.Name, eName, v.Value)
	}
	g.w.Writelnf(")")
}

func (g *Generator) makeStruct(s *ast.Struct) {
	for _, st := range s.Structs {
		g.makeStruct(&st)
	}

	for _, e := range s.Enums {
		g.makeEnum(&e)
	}

	g.writeComments(s.Comment)
	if ann := s.Annotations.ByName("deprecated"); ann != nil {
		g.w.Writelnf("// Deprecated: %s", ann.Arguments[0])
	}

	structName := common.StructName(s)
	g.structuresToRegister = append(g.structuresToRegister, structName)
	g.w.Writelnf("type %s struct {", structName)
	for _, f := range s.Fields {
		g.writeComments(f.Comment)
		if ann := f.Annotations.ByName("deprecated"); ann != nil {
			g.w.Writelnf("// Deprecated: %s", ann.Arguments[0])
		}
		g.w.Writelnf("%s %s `arf:\"%d\"`",
			strcase.ToCamel(f.Name),
			common.ConvertType(f.Type, g.resolvePackage),
			f.ID)
	}
	g.w.Writelnf("}")

	g.w.Writelnf("")

	g.w.Writelnf("func (%s) ArfStructID() string { return \"%s\" }",
		structName, common.CanonicalStructName(g.t.Package, s))
	g.w.Break()
}

func (g *Generator) generateMethodResponder(m *common.MethodDefinition) {
	name := m.ResponderName()
	g.requirePackage("github.com/arf-rpc/arf-go")
	g.requirePackage("github.com/arf-rpc/arf-go/status")
	g.requirePackage("context")
	g.w.Writelnf("func make%s(ctx context.Context, c arf.Context) *%s {", name, name)
	g.w.Writelnf("return &%s{make(chan error), ctx, c}", name)
	g.w.Writelnf("}")
	g.w.Writelnf("type %s struct {", name)
	g.w.Writelnf("error chan error")
	g.w.Writelnf("ctx context.Context")
	g.w.Writelnf("arfc arf.Context")
	g.w.Writelnf("}")
	if m.HasInputStream {
		g.w.Writelnf("func (x *%s) Recv() (v *%s, err error) {", name, common.ConvertType(m.InputStreamType, g.resolvePackage))
		g.w.Writelnf("return")
		g.w.Writelnf("}")
	}
	if m.HasOutput {
		g.w.Writef("func (x *%s) Respond(", name)
		for i, t := range m.Output {
			g.w.Writef("r%d ", i)
			if common.IsUserType(t) {
				g.w.Writef("*")
			}
			g.w.Writef("%s,", common.ConvertType(t, g.resolvePackage))
		}
		g.w.Writef(") (")
		if m.HasResponder() {
			g.w.Writef("out %s,", common.OutStreamer(m.OutputStreamType, g.resolvePackage))
		}
		g.w.Writelnf("err error) {")
		g.w.Writef("if err = x.arfc.SendResponse(status.OK, []any{")
		for i := range m.Output {
			g.w.Writef("r%d,", i)
		}
		g.w.Writelnf("}, true, nil); err != nil { return }")
		g.w.Writef("out = arf.MakeOutStream[")
		if common.IsUserType(m.OutputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s]", common.ConvertType(m.OutputStreamType, g.resolvePackage))
		g.w.Writelnf("(x.arfc)")
		g.w.Writelnf("return")
		g.w.Writelnf("}")
	}
}

func (g *Generator) makeExecutor(m *common.MethodDefinition) {
	g.requirePackage("github.com/arf-rpc/arf-go/status")
	g.w.Writelnf("func(ctx context.Context, c arf.Context) error {")
	if m.HasInput {
		g.w.Writelnf("_req := c.Request()")
		for i := range m.Inputs {
			if i != 0 {
				g.w.Writef(",")
			}
			g.w.Writef("p%d ", i)
		}
		g.w.Writef(":=")

		for i := range m.Inputs {
			if i != 0 {
				g.w.Writef(",")
			}
			g.w.Writef("_req.Params[%d].(", i)
			if common.IsUserType(m.Inputs[i].Type) {
				g.w.Writef("*")
			}
			g.w.Writef("%s) ", common.ConvertType(m.Inputs[i].Type, g.resolvePackage))
		}
	}
	g.w.Writelnf("")

	if m.HasResponder() {
		g.w.Writelnf("_responder := make%s(ctx, c)", m.ResponderName())
	} else {
		for i := range m.Output {
			g.w.Writef("r%d, ", i)
		}
	}
	g.w.Writef("err := ")
	g.w.Writef("i.%s(ctx,", strcase.ToCamel(m.Name))
	for i := range m.Inputs {
		g.w.Writef("p%d,", i)
	}

	switch {
	//case !m.HasInput && !m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
	case !m.HasInput && !m.HasOutput && !m.HasInputStream && m.HasOutputStream:
		g.w.Writef("arf.MakeOutStream[")
		if common.IsUserType(m.OutputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.OutputStreamType, g.resolvePackage))
	case !m.HasInput && !m.HasOutput && m.HasInputStream && !m.HasOutputStream:
		g.w.Writef("arf.MakeInStream[")
		if common.IsUserType(m.InputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.InputStreamType, g.resolvePackage))
	case !m.HasInput && !m.HasOutput && m.HasInputStream && m.HasOutputStream:

		g.w.Writef("arf.MakeInOutStream[")
		if common.IsUserType(m.InputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s, ", common.ConvertType(m.InputStreamType, g.resolvePackage))
		if common.IsUserType(m.OutputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.OutputStreamType, g.resolvePackage))
	//case !m.HasInput && m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
	case !m.HasInput && m.HasOutput && !m.HasInputStream && m.HasOutputStream:
		g.w.Writef("_responder")
	case !m.HasInput && m.HasOutput && m.HasInputStream && !m.HasOutputStream:
		g.w.Writef("arf.MakeInStream[")
		if common.IsUserType(m.InputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.InputStreamType, g.resolvePackage))
	case !m.HasInput && m.HasOutput && m.HasInputStream && m.HasOutputStream:
		g.w.Writef("_responder,")
	//case m.HasInput && !m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
	case m.HasInput && !m.HasOutput && !m.HasInputStream && m.HasOutputStream:
		g.w.Writef("arf.MakeOutStream[")
		if common.IsUserType(m.OutputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.OutputStreamType, g.resolvePackage))
	case m.HasInput && !m.HasOutput && m.HasInputStream && !m.HasOutputStream:
		g.w.Writef("arf.MakeInStream[")
		if common.IsUserType(m.InputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.InputStreamType, g.resolvePackage))
	case m.HasInput && !m.HasOutput && m.HasInputStream && m.HasOutputStream:
		g.w.Writef("arf.MakeInOutStream[")
		if common.IsUserType(m.InputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s, ", common.ConvertType(m.InputStreamType, g.resolvePackage))
		if common.IsUserType(m.OutputStreamType) {
			g.w.Writef("*")
		}
		g.w.Writef("%s](c),", common.ConvertType(m.OutputStreamType, g.resolvePackage))
	//case m.HasInput && m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
	case m.HasInput && m.HasOutput && !m.HasInputStream && m.HasOutputStream:
		g.w.Writef("_responder")
	case m.HasInput && m.HasOutput && m.HasInputStream && !m.HasOutputStream:
		g.w.Writef("_responder")
	case m.HasInput && m.HasOutput && m.HasInputStream && m.HasOutputStream:
		g.w.Writef("_responder")
	}

	g.w.Writelnf(")")
	g.w.Writelnf("if err != nil { return err }")

	// At this point, if we have a responder, we need to handle the responder
	// itself instead of the arguments.
	if m.HasResponder() {
		g.w.Writelnf("return <-_responder.error")
	} else if len(m.Output) > 0 {
		g.w.Writef("return c.SendResponse(status.OK, []any{")
		for i := range m.Output {
			g.w.Writef("r%d,", i)
		}
		g.w.Writelnf("}, false, nil)")
	} else {
		g.w.Writelnf("return nil")
	}

	g.w.Writelnf("},")
}

func (g *Generator) makeDefinition(m *ast.ServiceMethod) *common.MethodDefinition {
	def := &common.MethodDefinition{
		Tree:   g.t,
		Name:   m.Name,
		Method: m,
		Inputs: nil,
		Output: nil,

		HasInput:        false,
		HasOutput:       false,
		HasInputStream:  false,
		HasOutputStream: false,

		InputStreamType:  nil,
		OutputStreamType: nil,
	}

	for _, i := range m.Params {
		if i.Stream {
			def.HasInputStream = true
			def.InputStreamType = i.Type
		} else {
			def.HasInput = true
			def.Inputs = append(def.Inputs, common.MethodInput{
				Name: *i.Name,
				Type: i.Type,
			})
		}
	}

	for _, o := range m.Returns {
		if o.Stream {
			def.HasOutputStream = true
			def.OutputStreamType = o.Type
		} else {
			def.HasOutput = true
			def.Output = append(def.Output, o.Type)
		}
	}

	return def
}

func (g *Generator) makeService(s *ast.Service) {
	g.requirePackage("github.com/arf-rpc/arf-go")
	g.requirePackage("context")

	g.w.Writelnf("func Register%s(s arf.Server, i %s) error {", s.Name, s.Name)
	g.w.Writelnf("__arfRegister%sStructures()", composedPackage(g.t.Package))
	g.w.Writelnf("return s.RegisterService(arf.ServiceAdapter{")
	g.w.Writelnf("Methods: map[string]arf.ServiceExecutor{")
	defs := make([]*common.MethodDefinition, len(s.Methods))
	for i, v := range s.Methods {
		defs[i] = g.makeDefinition(v)
	}
	for _, m := range defs {
		g.w.Writef("%q:", m.Name)
		g.makeExecutor(m)
	}
	g.w.Writelnf("},")
	g.w.Writelnf("ServiceID: %q,", fmt.Sprintf("%s/%s", g.t.Package, s.Name))
	g.w.Writelnf("})")
	g.w.Writelnf("}")

	g.w.Writelnf("")
	g.w.Writelnf("func MustRegister%s(s arf.Server, i %s) {", s.Name, s.Name)
	g.w.Writelnf("if err := Register%s(s, i); err != nil { panic(err) }", s.Name)
	g.w.Writelnf("}")

	for _, m := range defs {
		if m.HasResponder() {
			g.generateMethodResponder(m)
		}
	}

	g.w.Writelnf("type %s interface {", s.Name)
	for _, m := range defs {
		g.writeComments(m.Method.Comment)
		if ann := m.Method.Annotations.ByName("deprecated"); ann != nil {
			g.w.Writelnf("Deprecated: %s", ann.Arguments[0])
		}
		m.BuildInterfaceSignature(g.w, g.resolvePackage)
	}
	g.w.Writelnf("}")
}

func (g *Generator) makeClient(s *ast.Service) {
	g.requirePackage("github.com/arf-rpc/arf-go")
	g.requirePackage("context")
	g.w.Writelnf("func New%sClient(c arf.Client) *%sClient {", s.Name, s.Name)
	g.w.Writelnf("__arfRegister%sStructures()", composedPackage(g.t.Package))
	g.w.Writelnf("return &%sClient{c: c}", s.Name)
	g.w.Writelnf("}")
	g.w.Writelnf("")

	g.w.Writelnf("type %sClient struct {", s.Name)
	g.w.Writelnf("c arf.Client")
	g.w.Writelnf("}")

	defs := make([]*common.MethodDefinition, len(s.Methods))
	for i, m := range s.Methods {
		defs[i] = g.makeDefinition(m)
	}

	for _, m := range defs {
		g.w.Writef("func (x *%sClient) %s(ctx context.Context,", s.Name, strcase.ToCamel(m.Name))
		switch {
		case !m.HasInput && !m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
			g.w.Writelnf("opts ...arf.CallOption) error {")
		case !m.HasInput && !m.HasOutput && !m.HasInputStream && m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (%s, error) {", common.InStreamer(m.OutputStreamType, g.resolvePackage))
		case !m.HasInput && !m.HasOutput && m.HasInputStream && !m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (%s, error) {", common.OutStreamer(m.InputStreamType, g.resolvePackage))
		case !m.HasInput && !m.HasOutput && m.HasInputStream && m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (%s, error) {", common.InOutStreamer(m.OutputStreamType, m.InputStreamType, g.resolvePackage))
		case !m.HasInput && m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (")
			for _, v := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(v, g.resolvePackage))
			}
			g.w.Writelnf("error) {")
		case !m.HasInput && m.HasOutput && !m.HasInputStream && m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (")
			for _, v := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(v, g.resolvePackage))
			}
			g.w.Writelnf(" %s, error) {", common.InStreamer(m.OutputStreamType, g.resolvePackage))
		case !m.HasInput && m.HasOutput && m.HasInputStream && !m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (")
			for _, v := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(v, g.resolvePackage))
			}
			g.w.Writelnf("%s, error) {", common.InStreamer(m.InputStreamType, g.resolvePackage))
		case !m.HasInput && m.HasOutput && m.HasInputStream && m.HasOutputStream:
			g.w.Writef("opts ...arf.CallOption) (")
			for _, v := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(v, g.resolvePackage))
			}
			g.w.Writelnf("%s, error) {", common.InOutStreamer(m.OutputStreamType, m.InputStreamType, g.resolvePackage))
		case m.HasInput && !m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writelnf("opts ...arf.CallOption) error {")
		case m.HasInput && !m.HasOutput && !m.HasInputStream && m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writelnf("opts ...arf.CallOption) (%s, error) {", common.InStreamer(m.OutputStreamType, g.resolvePackage))
		case m.HasInput && !m.HasOutput && m.HasInputStream && !m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writelnf("opts ...arf.CallOption) (%s, error) {", common.OutStreamer(m.InputStreamType, g.resolvePackage))
		case m.HasInput && !m.HasOutput && m.HasInputStream && m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writelnf("opts ...arf.CallOption) (%s, error) {", common.InOutStreamer(m.OutputStreamType, m.InputStreamType, g.resolvePackage))
		case m.HasInput && m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writef("opts ...arf.CallOption) (")
			for _, o := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf("error) {")

		case m.HasInput && m.HasOutput && !m.HasInputStream && m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writef("opts ...arf.CallOption) (")
			for _, o := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf("%s, error) {", common.InStreamer(m.OutputStreamType, g.resolvePackage))

		case m.HasInput && m.HasOutput && m.HasInputStream && !m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writef("opts ...arf.CallOption) (")
			for _, o := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf("%s, error) {", common.InStreamer(m.OutputStreamType, g.resolvePackage))
		case m.HasInput && m.HasOutput && m.HasInputStream && m.HasOutputStream:
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d ", idx)
				} else {
					g.w.Writef("%s ", i.Name)
				}
				g.w.Writef("%s, ", common.MaybePointer(i.Type, g.resolvePackage))
			}
			g.w.Writef("opts ...arf.CallOption) (")
			for _, o := range m.Output {
				g.w.Writef("%s, ", common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf("%s, error) {", common.InOutStreamer(m.OutputStreamType, m.InputStreamType, g.resolvePackage))
		}

		if m.HasInput {
			g.w.Writef("opts = append(opts, arf.WithParams(")
			for idx, i := range m.Inputs {
				if i.Name == "" {
					g.w.Writef("p%d,", idx)
				} else {
					g.w.Writef("%s,", i.Name)
				}
			}
			g.w.Writelnf("))")
		}

		if m.HasInputStream {
			g.w.Writelnf("opts = append(opts, arf.WithStream())")
		}

		g.w.Writelnf("_req, err := x.c.Call(ctx, %q, %q, opts...)", g.t.Package+"/"+s.Name, m.Name)

		switch {
		case !m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
			g.w.Writelnf("if err != nil { return err }")
			g.w.Writelnf("_, err = _req.Response().Result()")
			g.w.Writelnf("return err")
		case !m.HasOutput && !m.HasInputStream && m.HasOutputStream:
			g.w.Writelnf("if err != nil { return nil, err }")
			g.w.Writelnf("return arf.MakeInStream[%s](_req), nil", common.MaybePointer(m.OutputStreamType, g.resolvePackage))

		case !m.HasOutput && m.HasInputStream && !m.HasOutputStream:
			g.w.Writelnf("if err != nil { return nil, err }")
			g.w.Writelnf("return arf.MakeOutStream[%s](_req), nil", common.MaybePointer(m.InputStreamType, g.resolvePackage))
		case !m.HasOutput && m.HasInputStream && m.HasOutputStream:
			g.w.Writelnf("if err != nil { return nil, err }")
			g.w.Writelnf("return arf.MakeInOutStream[%s, %s](_req), nil", common.MaybePointer(m.OutputStreamType, g.resolvePackage), common.MaybePointer(m.InputStreamType, g.resolvePackage))
		case m.HasOutput && !m.HasInputStream && !m.HasOutputStream:
			g.w.Writelnf("var (")
			for i, o := range m.Output {
				g.w.Writelnf("r%d %s", i, common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf(")")
			g.w.Writelnf("params, err := _req.Response().Result()")
			g.w.Writelnf("if err != nil {")
			g.w.Writef("return ")
			for i := range m.Output {
				g.w.Writef("r%d, ", i)
			}
			g.w.Writelnf("err")
			g.w.Writelnf("}")

			for idx := range m.Output {
				g.w.Writef("r%d", idx)
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}
			g.w.Writef("=")
			for idx, o := range m.Output {
				g.w.Writef("params[%d].(%s)", idx, common.MaybePointer(o, g.resolvePackage))
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}
			g.w.Writelnf("")

			g.w.Writef("return ")
			for idx := range m.Output {
				g.w.Writef("r%d, ", idx)
			}
			g.w.Writelnf("err")
		case m.HasOutput && !m.HasInputStream && m.HasOutputStream:
			g.w.Writelnf("var (")
			for i, o := range m.Output {
				g.w.Writelnf("r%d %s", i, common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf(")")
			g.w.Writelnf("params, err := _req.Response().Result()")
			g.w.Writelnf("if err != nil {")
			g.w.Writef("return ")
			for i := range m.Output {
				g.w.Writef("r%d, ", i)
			}
			g.w.Writelnf(" nil, err")
			g.w.Writelnf("}")

			for idx := range m.Output {
				g.w.Writef("r%d", idx)
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}
			g.w.Writef("=")
			for idx, o := range m.Output {
				g.w.Writef("params[%d].(%s)", idx, common.MaybePointer(o, g.resolvePackage))
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}
			g.w.Writelnf("")

			g.w.Writef("return ")
			for idx := range m.Output {
				g.w.Writef("r%d, ", idx)
			}
			g.w.Writelnf("arf.MakeInStream[%s](_req), err", common.MaybePointer(m.OutputStreamType, g.resolvePackage))
		case m.HasOutput && m.HasInputStream && !m.HasOutputStream:
			g.w.Writelnf("var (")
			for i, o := range m.Output {
				g.w.Writelnf("r%d %s", i, common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf(")")
			g.w.Writelnf("params, err := _req.Response().Result()")
			g.w.Writelnf("if err != nil {")
			g.w.Writef("return ")
			for i := range m.Output {
				g.w.Writef("r%d, ", i)
			}
			g.w.Writelnf("nil, err")
			g.w.Writelnf("}")

			for idx := range m.Output {
				g.w.Writef("r%d", idx)
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}
			g.w.Writef("=")
			for idx, o := range m.Output {
				g.w.Writef("params[%d].(%s)", idx, common.MaybePointer(o, g.resolvePackage))
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}

			g.w.Writelnf("")

			g.w.Writef("return ")
			for idx := range m.Output {
				g.w.Writef("r%d, ", idx)
			}
			g.w.Writelnf("arf.MakeInStream[%s](_req), err", common.MaybePointer(m.InputStreamType, g.resolvePackage))
		case m.HasOutput && m.HasInputStream && m.HasOutputStream:
			g.w.Writelnf("var (")
			for i, o := range m.Output {
				g.w.Writelnf("r%d %s", i, common.MaybePointer(o, g.resolvePackage))
			}
			g.w.Writelnf(")")
			g.w.Writelnf("params, err := _req.Response().Result()")
			g.w.Writelnf("if err != nil {")
			g.w.Writef("return ")
			for i := range m.Output {
				g.w.Writef("r%d, ", i)
			}
			g.w.Writelnf("nil, err")
			g.w.Writelnf("}")

			for idx := range m.Output {
				g.w.Writef("r%d", idx)
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}
			g.w.Writef("=")
			for idx, o := range m.Output {
				g.w.Writef("params[%d].(%s)", idx, common.MaybePointer(o, g.resolvePackage))
				if idx != len(m.Output)-1 {
					g.w.Writef(",")
				}
			}

			g.w.Writelnf("")
			g.w.Writef("return ")
			for idx := range m.Output {
				g.w.Writef("r%d, ", idx)
			}
			g.w.Writelnf("arf.MakeInOutStream[%s, %s](_req), err", common.MaybePointer(m.OutputStreamType, g.resolvePackage), common.MaybePointer(m.InputStreamType, g.resolvePackage))
		}

		g.w.Writelnf("}")
		g.w.Writelnf("")
	}
}
